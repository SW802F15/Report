\section{Pair Programming}
\Ivan{Kap 10.1-3: SÃ¸rg for at uddyb dem grundigt!}
Throughout the project we experimented with and observed several interesting things.
We experimented with things like \textit{workstation setup} and \textit{scheduled partner switches}.
During the project we made interesting observations about \textit{interpersonal compatibility}, \textit{expertise level}, \textit{roles}, \textit{distractions}, \textit{quality}, and \textit{productivity}.

\subsection{Workstation Setup}
We have experimented with different kinds of workstation setup.
The first setup we used was by exclusively using our laptops without any peripherals, i.e., two people sharing one laptop.
This resulted in difficulties for the co-driver, as it was difficult to see what was happening on the screen, due to their low quality.
Additionally, due to the size of the laptop, it gave a sense of the driver working on his personal computer while the co-driver just observed quietly in the background, giving little sign of collaboration.

The second setup we used was a purely digital solution, where we used TeamViewer to share our screens.
We used this setup to counter the bad viewing angles of the screens, by placing each developer in front of his own screen.
Further it should improve the collaboration, by allowing each developer to take an active roll in the development process.
We experienced this as a more comfortable way of working, now that we were not slumping over a single laptop.
However, it gave rise to the tendency of hiding behind ones screen, even getting distracted and doing non-work related activities, leading to even less collaboration than with the first setup.
Consequently, working with TeamViewer proved to hinder productivity more than it helped.

The third and last setup we used was two workstations each consisting of a monitor, a keyboard, and a mouse.
This solved some of the problems we encountered with the two other setups: there were no longer problems with bad viewing angles or sitting positions, and the co-driver could no longer hide behind his own screen.
Additionally it removed the need for one person being forced to work on another's personal laptop, which could have been seen as a personal space violation.

Based on our experiences it was clearly the third setup that was the best.
It provided, by far, the best work environment, which allowed us to focus on some of the other challenges associated with pair programming.
On top of this it improved the communication between the pair, resulting in better quality code, through instant code review and better collaboration.
In contrast, a bad work environment, as with the first two setups, makes collaboration harder, which strongly diminishes the benefits from using pair programming.


\subsection{Scheduled Partner Switches}
Switching partners often is an important aspect of pair programming, as it helps getting new eyes on a problem and strengthens the feeling of collective ownership, by having more people work on the same piece of code.
For this we also experimented with three different approaches.

In the first approach, we changed partners whenever it felt like a good idea, but with no other restrictions than having to try doing it often, it was easy to forget.
This resulted in the same pair often sticking together for one or even several days, which was even more problematic, especially when one of the pairs was stuck with a problem that could easily be solved by changing partners.

To solve the problem of having too few partner switches, we experimented with having a fixed time of the day, where the switch occurred.
The change was an improvement in terms of improving the feeling of collective ownership as well as preventing one pair of getting stuck with a difficult problem for too long, but it also resulted in having to split a pair in the middle of finishing a task.
Being forced to stop working during a good flow often had a negative impact on the pair, causing them to be less useful for their new partners.

The problems connected to switching partners at a fixed time led us to make a small modification to the approach, resulting in the third and final approach: using a fixed time, but allowing each pair to finish their current task.
This approach definitely reduced the problems from the second approach, but it required some extra care in execution, as it would some times lead to one pair waiting for the other to finish a long task. Ideally no tasks should be long enough to have this be a big problem, but in reality a task can easily prove more difficult than anticipated.

Although the third approach provided the best balance of forcing us to switch partners often while still allowing a good work flow, it is not an ideal approach.
We are not sure how the ideal approach would look like, but it may depend on the team using it.

\subsection{Interpersonal Compatibility}
Pair programming requires tight cooperation between two people, and for that to run smoothly they need good communication and understanding of each other's way of working.
In other words, their personalities need to be compatible.
This is not something we have experimented with, but we have made some interesting observations. 

In our team, each person generally got along well, but when two specific members were paired up, some problems were observed.
The problems did not result in any big problems, but they did have a negative impact on the productivity of that pair.
One of the persons was decisive and responsive, and the other more cautious and reflective.
Some times a pair like that can support each other, making up for each other's shortcomings, but in this case their work flow differed in such a way, that they would become frustrated with each other.
For example, the reflective person may be driving, and they are trying to solve a difficult problem. The driver sits back and starts thinking about how to solve the problem.
Meanwhile, the decisive person already has three ideas that might work, and he is itching to try them out, quickly jotting down some code and hitting the hotkey to compile the program to see if it worked.
Eventually the reflective driver takes care to write the right code and slowly moves the cursor to the compile button, to make sure that the solution does indeed work.

Both would likely have solved the problem at the same speed in the end, but now the decisive person is left with a feeling that the process was too slow, and if he had opened his mouth to suggest his ideas, he would have disturbed the reflective person's thoughts, similarly leaving him with a feeling that they were slowed down.

Some of these problems could maybe be alleviated if we had been better at switching roles (i.e., letting the other person drive), but sometimes it can be very difficult to force two conflicting personalities to work together, and we believe it is important to try and make a team where conflicting personalities either are not present, or at least where they are not forced to work together.
Avoiding a certain combination in a pair may, in conclusion, be preferable to making sure all possible combinations of pairs are used throughout the project.


\subsection{Roles}
The pair consists of two roles: a driver and a co-driver.
The driver takes care of the coding and the co-driver keeps a sense of perspective and continuously reviews the code while the driver writes it.
For the pair programming to work it is there are communication between both roles.

The driver role was in charge of writing the code.
We, at first, experienced that it would put some pressure on the driver, as he was worried about making mistakes.
This problem solved itself with experience and collaboration.
Further, the technical skills of the driver, must be relatively high to understand and implement the ideas of the co-driver.
In situations where the technical skills of the driver were insufficient, the inadequacy was overcome through communication or a role change was performed.

The co-driver role was continuously reviewing the code and making sure it made sense in the larger perspective.
To achieve this, his role was often to initialise the communication.
For some it took a bit of practice to be able to break the ice, but once the fear of intrusion was overcome, it was no problem at all.
Another difficulty we observed, was when the co-driver was too eager to share his thoughts, that he broke the driver's flow, just to tell him about a typo.
This difficulty was remedied through experience, however, we are still not completely able to tell when the driver is ``in the zone''.
We believe with experience this occurrence will be so rare, it will not affect the pair programming much.
Another problem we observed was, when the co-driver had difficulty expressing his thoughts, due to the lack of a technical vocabulary.
These types of problems were usually solved by writing prototypes or having longer discussion session.

A general problem was the difficulty of instantly being the co-driver after a pair switch.
After a pair switch, one would often lack perspective and therefore not always realise the reasons for the drivers actions.
There are two options for solving this problem: either the driver takes some time to explain the situation to the co-driver, or the co-driver spends some time trying to get an overview of the situation, while the driver continues programming.
Both of those options do, however, have  negative side effects.
The former results in a time-wise overhead, and the latter would result in a period where pair programming is not really taking place, resulting in lower quality code, as the co-driver has to focus on understanding rather than providing a code review.


\subsection{Quality}
One of the major arguments for using pair programming is that is improves the quality of the code produced.
Although we have no metrics to prove it, we feel like the code we produced was generally of a higher quality than what we usually produce when programming individually.
This increase in quality, is partly because of the instant code review given by the co-driver, which results in less need for refactoring, and easier maintenance of the code.
Further, the solutions are often more elegant when pair programming than when programming individually.


\subsection{Productivity}
%when both have no idea or expertise
%distractions and keeping each other working
%Faster ideas
%Trivial issues vs complicated issues
%Mention less refactoring (code review) from quality






%pp generelt
%koble det til pp i kap 2 adaptation