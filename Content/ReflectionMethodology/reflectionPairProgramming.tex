\section{Pair Programming}
\Ivan{Kap 10.1-3: SÃ¸rg for at uddyb dem grundigt!}
Throughout the project we experimented with and observed several interesting things.
We experimented with things like \textit{workstation setup} and \textit{scheduled partner switches}.
During the project we made interesting observations about \textit{interpersonal compatibility}, \textit{roles}, \textit{quality}, and \textit{productivity}.

\subsection{Workstation Setup}
We have experimented with different kinds of workstation setup.
The first setup we used was by exclusively using our laptops without any peripherals, i.e., two people sharing one laptop.
This resulted in difficulties for the co-driver, as it was difficult to see what was happening on the screen, due to their low quality.
Additionally, due to the size of the laptop, it gave a sense of the driver working on his personal computer while the co-driver just observed quietly in the background, giving little sign of collaboration.

The second setup we used was a purely digital solution, where we used TeamViewer to share our screens.
We used this setup to counter the bad viewing angles of the screens, by placing each developer in front of his own screen.
Further it should improve the collaboration, by allowing each developer to take an active roll in the development process.
We experienced this as a more comfortable way of working, now that we were not slumping over a single laptop.
However, it gave rise to the tendency of hiding behind ones screen, even getting distracted and doing non-work related activities, leading to even less collaboration than with the first setup.
Consequently, working with TeamViewer proved to hinder productivity more than it helped.

The third and last setup we used was two workstations each consisting of a monitor, a keyboard, and a mouse.
This solved some of the problems we encountered with the two other setups: there were no longer problems with bad viewing angles or sitting positions, and the co-driver could no longer hide behind his own screen.
Additionally it removed the need for one person being forced to work on another's personal laptop, which could have been seen as a personal space violation.

Based on our experiences it was clearly the third setup that was the best.
It provided, by far, the best work environment, which allowed us to focus on some of the other challenges associated with pair programming.
On top of this it improved the communication between the pair, resulting in better quality code, through instant code review and better collaboration.
In contrast, a bad work environment, as with the first two setups, makes collaboration harder, which strongly diminishes the benefits from using pair programming.


\subsection{Scheduled Partner Switches}
Switching partners often is an important aspect of pair programming, as it helps getting new eyes on a problem and strengthens the feeling of collective ownership, by having more people work on the same piece of code.
For this we also experimented with three different approaches.

In the first approach, we changed partners whenever it felt like a good idea, but with no other restrictions than having to try doing it often, it was easy to forget.
This resulted in the same pair often sticking together for one or even several days, which was even more problematic, especially when one of the pairs was stuck with a problem that could easily be solved by changing partners.

To solve the problem of having too few partner switches, we experimented with having a fixed time of the day, where the switch occurred.
The change was an improvement in terms of improving the feeling of collective ownership as well as preventing one pair of getting stuck with a difficult problem for too long, but it also resulted in having to split a pair in the middle of finishing a task.
Being forced to stop working during a good flow often had a negative impact on the pair, causing them to be less useful for their new partners.

The problems connected to switching partners at a fixed time led us to make a small modification to the approach, resulting in the third and final approach: using a fixed time, but allowing each pair to finish their current task.
This approach definitely reduced the problems from the second approach, but it required some extra care in execution, as it would some times lead to one pair waiting for the other to finish a long task. Ideally no tasks should be long enough to have this be a big problem, but in reality a task can easily prove more difficult than anticipated.

Although the third approach provided the best balance of forcing us to switch partners often while still allowing a good work flow, it is not an ideal approach.
We are not sure how the ideal approach would look like, but it may depend on the team using it.

\subsection{Interpersonal Compatibility}
Pair programming requires tight cooperation between two people, and for that to run smoothly they need good communication and understanding of each other's way of working.
In other words, their personalities need to be compatible.
This is not something we have experimented with, but we have made some interesting observations. 

In our team, each person generally got along well, but when two specific members were paired up, some problems were observed.
The problems did not result in any big problems, but they did have a negative impact on the productivity of that pair.
One of the persons was decisive and responsive, and the other more cautious and reflective.
Some times a pair like that can support each other, making up for each other's shortcomings, but in this case their work flow differed in such a way, that they would become frustrated with each other.
For example, the reflective person may be driving, and they are trying to solve a difficult problem. The driver sits back and starts thinking about how to solve the problem.
Meanwhile, the decisive person already has three ideas that might work, and he is itching to try them out, quickly jotting down some code and hitting the hotkey to compile the program to see if it worked.
Eventually the reflective driver takes care to write the right code and slowly moves the cursor to the compile button, to make sure that the solution does indeed work.

Both would likely have solved the problem at the same speed in the end, but now the decisive person is left with a feeling that the process was too slow, and if he had opened his mouth to suggest his ideas, he would have disturbed the reflective person's thoughts, similarly leaving him with a feeling that they were slowed down.

Some of these problems could maybe be alleviated if we had been better at switching roles (i.e., letting the other person drive), but sometimes it can be very difficult to force two conflicting personalities to work together, and we believe it is important to try and make a team where conflicting personalities either are not present, or at least where they are not forced to work together.
Avoiding a certain combination in a pair may, in conclusion, be preferable to making sure all possible combinations of pairs are used throughout the project.

\subsection{Roles}
The pair consists of two roles: a driver and a co-driver.
The driver takes care of the coding and the co-driver keeps a sense of perspective and continuously reviews the code while the driver writes it.
For the pair programming to work it is there are communication between both roles.

The driver role was in charge of writing the code.
We, at first, experienced that it would put some pressure on the driver, as he was worried about making mistakes.
This problem solved itself with experience and collaboration.
Further, the technical skills of the driver, must be relatively high to understand and implement the ideas of the co-driver.
In situations where the technical skills of the driver were insufficient, the inadequacy was overcome through communication or a role change was performed.

The co-driver role was continuously reviewing the code and making sure it made sense in the larger perspective.
To achieve this, his role was often to initialise the communication.
For some it took a bit of practice to be able to break the ice, but once the fear of intrusion was overcome, it was no problem at all.
Another difficulty we observed, was when the co-driver was too eager to share his thoughts, that he broke the driver's flow, just to tell him about a typo.
This difficulty was remedied through experience, however, we are still not completely able to tell when the driver is ``in the zone''.
We believe with experience this occurrence will be so rare, it will not affect the pair programming much.
Another problem we observed was, when the co-driver had difficulty expressing his thoughts, due to the lack of a technical vocabulary.
These types of problems were usually solved by writing prototypes or having longer discussion session.

A general problem was the difficulty of instantly being the co-driver after a pair switch.
After a pair switch, one would often lack perspective and therefore not always realise the reasons for the drivers actions.
There are two options for solving this problem: either the driver takes some time to explain the situation to the co-driver, or the co-driver spends some time trying to get an overview of the situation, while the driver continues programming.
Both of those options do, however, have  negative side effects.
The former results in a time-wise overhead, and the latter would result in a period where pair programming is not really taking place, resulting in lower quality code, as the co-driver has to focus on understanding rather than providing a code review.

\subsection{Quality}
One of the major arguments for using pair programming is that is improves the quality of the code produced.
Although we have no metrics to prove it, we feel like the code we produced was generally of a higher quality than what we usually produce when programming individually.
This increase in quality, is partly because of the instant code review given by the co-driver, which results in less need for refactoring, and easier maintenance of the code.
Further, the solutions are often more elegant when pair programming than when programming individually.

\subsection{Productivity}
One of the major concerns about pair programming is whether it is productive enough to restrict the work force of two developers for a single story.
We are not in a position to provide a definite conclusion on this, but in our opinion it depends on the team using it.

We experienced and rectified some problems with using pair programming in our team.
First off, when a problem was outside the expertise of both developers, they would both search the internet for an answer.
This would usually lead to both developers reading the same material and experimenting with the same solutions, which is unproductive, since two developers are doing the same task, while one of them might as well have spent their time on another task.

Secondly, we discovered that if part of the pair got distracted, the other would likely get distracted as well.
This gave rise to some situations where both developers unknowingly supported each other's unproductiveness.
These situations often happened when the co-driver was exhausted and then got easily distracted.
To avoid problems like this, both partners has to help each other keep focus, and tell each other to get it together if necessary.
The lack of focus may, however, be contributed to a number of different influences, such as too few breaks or too little communication.
The underlying issues need to be taken care of on a case to case basis.

While some times having problems with distractions, we more often experienced the pair motivating each other to keep working.
Having a partner when working on something gives a sense of obligation, and as long as neither start getting distracted, pair programming works great for keeping a good work morale.

When working on a project, some of the stories will be trivial to implement.
In these situations a single programmer could easily write high quality code by himself, making pair programming less beneficial.
Determining when a task is too trivial to require pair programming is difficult, and the resulting overhead from trying to determine this, may be better spent on actually implementing the story while pair programming.

It is when implementing complicated stories, that pair programming really shines.
It allows for a synergetic effect between the driver and co-driver, allowing them to work better than the two would do separately.
The driver has a sparring partner for helping with ideas, structure, and perspective, and as such he is free to concentrate on the how to implement the story.
The co-driver will through communication understand what the driver has in mind, helping him improve his suggestions.
We experienced this synergetic effect quite a number of times, leaving us with the feeling of pair programming being more productive than individual programming.

\subsection{Summary}
In summation we used the workstation setup as planned in \Cref{def:pairprogramming} and compared it to other workstation setups.
We tried experimenting with different aspects of the practise, as we had planned in \Cref{def:pairprogramming}.
We found the practise to be very dependent on which team is using it.
We will therefore recommend others to experiment with the different aspects to find what works for them.
