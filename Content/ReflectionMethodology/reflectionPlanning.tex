\section{Planning Game}
Planning is a useful tool.
We used it primarily as a tool for measuring our velocity, to get an overview of our progress, and to know if we were falling behind schedule.
Additionally it helps keep the project progressing as the customer desires, by allowing the customer to continuously create user stories, which should be implemented.

\subsection{The Customer's Role}
The main responsibilities of the customer, in regards to planning, is to create user stories and prioritise in which order they should be implemented.
As stated in \Cref{def:onsitecustomer}, we used a surrogate customer, which meant we were responsible for the tasks normally appointed to the customer.

%User Stories
The first task we needed to do, was create the user stories.
The creation of the user stories went fairly easy, but we later found that these were much larger than desired.
We would therefore split them into several smaller, more well defined, user stories.
We felt that having an oral agreement was a more flexible tool for creating issues, so a lot of the time the stores were not written down.
Taking the time to write the issues down would have helped us make sure, that there was total agreement about what each story should achieve, but it would also result in having to spend more time on rewriting the story if changes occurred, possibly discouraging us from making changes.

%Prioritising
After the user stories were estimated it was our responsibility, as surrogate customers, to prioritise in what order the user stories should be implemented.
Usually we prioritised them as we suspected an on-site customer would, according to cost/benefit.
However, after the basic modules of the program were implemented, we started letting our developer hearts influence the decisions.
We started to prioritise the user stories by novelty, which essentially means by what we found new and interesting to implement.
This caused the product to be more of a proof-of-concept product instead of the initial intended usable product.
Although the product did not end up as what was intended from the get go, it showed us that XP was capable of embracing change.


\subsection{Making Estimations}
To properly plan an iteration, it is important to have precise estimations of the issues at hand.
It allows the customer to easier prioritise each user story, and it allows the developers to have an idea of how many issues they can finish during the iteration.

Estimating an user story correctly is, however, a difficult task.
Many variables play a role in how long it takes to implement an user story, and it is often impossible to foresee them all.
To try to reduce this problem we employed the practice of planning poker, where each member of the team gives their own (anonymous) estimation, and the final estimation is discussed afterwards.
We found that in the first iterations we underestimated the amount of time needed for the more difficult issues, while we generally estimated correctly when it came to trivial issues.
The underestimation was likely linked to our inexperience, and we tried to bring our new gained knowledge to the next planning meetings.
This resulted in us beginning to overestimate the harder stories instead, as we were overcompensating for the fact that we underestimated them before.
As time went on, we got closer to being correct with medium hard stories, but the harder ones kept being estimated either too high or too low.

As a way of trying to simplify the estimation process, we switched from estimating a story to take a number of hours to take a number of units instead, each unit being half a day.
\Dan{Kan vi huske en kilde på hvor Beck siger det er en god idé?}
This allowed us to better put the estimation into perspective in terms of development time, which in turn helped giving us a better idea of how long time a given story should get.
%But did it help?

\subsection{Code Velocity}
%Velocity and fragmentation
The code velocity is a metric describing how fast the team can implement features.
It is an important metric, as it is used to plan what should be implemented next, but also when the customer can expect the product finished.
Without an approximate velocity, it is nearly impossible to plan an iteration, let alone a release.

The code velocity is measured, as the sum of the units, for all implemented user stories from last iteration.
That does by definition need some way of tracking how much time is used to implement each user story.
For the first iteration we manually tracked the implementation time. This method was not anywhere near precise, as we approximated most implementation times, since we forgot to track breaks and the like. This caused us to have difficulty determining the amount of work we could do in an iteration. Therefore we decided to use an automated time tracking tool.

From the second iteration onward, we used the time tracking tool EverHour. 
This gave us much more precise implementation times, all the way down to the second.
However, although our implementation times were much more precise, our code velocity was still off.
We found this to be because of the time units used to measure velocity.
We had used hours, minutes, and seconds as measurement, e.g. we got an code velocity of 64 hours and 27 minutes.
Even by rounded off to the nearest hour, our velocity would be way off.

We studied our user stories and found that their implementation times differed slightly in comparison to the estimated times, but the accumulated difference was quite high.
We determined it was the granularity of the measuring units, which were at fault.
We implemented the use of half-a-day units instead, and found the code velocity to be quite accurate, now only disrupted by isolated errors of estimation.

\subsection{Summary}
Doing all of these tasks associated with planning takes a lot of time, but are they really worth it?
Based on our experiences, the short answer is: yes.
As mentioned in \Cref{def:planninggame} planning lets you know your velocity, plans for the future, and allows for responding to change rather quickly.


%Overhead
%Flexibility (in terms of changes)
\Alexander{Check for Planning vs. Planning Game}
