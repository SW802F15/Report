\section{What is Extreme Programming?}
XP (Extreme Programming) is an agile development methodology and this project is developed using the principles of XP. XP follows 12 core practices as decribed by \citet[p. 54]{xp:explained}.

The purpose of the 12 practices is to ease the development of high quality software. This is partly done by ensuring thorough testing, continuous refactoring, and efficient knowledge sharing. XP further encourages improving oneself and the team as a whole.

For the practices to work there are some criteria that need to be met, some of those criteria are:
\begin{itemize}
\item The size of an XP team should not exceed ten members.
\item Iterations should not exceed four weeks, but two-three weeks are preferable.
\item The team should be self-organising and should not be controlled by a boss.
\item The team members must be able to embrace change.
\item The team should have their workstations placed in the same room.
\item All the practices must be followed to utilise the full potential of XP.
\end{itemize}

The listed criteria are fulfilled by this project.

\subsection{Approach}
According to \citet[p. 53]{xp:explained}, the idea behind these practices is that while one practice in itself can be weak, the other practices cover that weakness, creating a synergy effect between the practices.

%Continued practices
While all the practices are followed in this project, some need more thought than others. In the following we will explain we use each practice. It is important to note that these descriptions are for ideal scenarios, and some alterations may be made when applying them.

\paragraph{The Planning Game} has been discarded in favour of Planning Poker as described by \citet{xp:planningPoker}.\Christoffer{do we follow this completely?}
\Christoffer{skal omskrives til at have en beskrivelse og rationale bag brug af collaborative estimation i stedet for det traditionelle planning game}
The main difference is how conflicting estimations are resolved. 

Planning Poker starts with the team discussing the task. This ensures everybody understand the scope and task at hand. This will in-turn reduce disparity of the individual estimates, and make it easier to agree on an estimate. Each member then considers his estimate and keeps it to himself. When all are ready, everybody reveals their estimate at the same time. If there is great disparity between estimates, a discussion is organised. When this discussion is over, everybody estimates the task again. If the conflict still exists, estimation of the task is postponed, the task is split or the lowest estimation is taken according to \citet[p. 1]{xp:planningPoker}.

The Planning Game starts with the team discussing the task. Then each member considers his estimate and reports this to the team. If a conflict arises, the lowest estimate is chosen, as stated by \citet[p. 58]{xp:planning}.
This way of reporting individual estimates may influence the estimation of other team member. 
 \Alexander{Explained p.153 description of individual version of planning game (should be used?).
			Planning p.58 description of collaborative version of planning game (used in report).
			We originally chose Poker Planning because we only knew the individual version of Planning Game.}
 \Alexander{Explained p.157, Planning game not necessary four teams of 3-4 developers.}

\paragraph{Small releases} are ensured by prioritising important tasks and making sure to have a working product for each release. A release should not take more than a few iterations, because the short time frame of the project makes it critical that we discover problems as early as possible, allowing us to discard less important features to have time to fix these problems.

\paragraph{Metaphors} \textit{``guide all development with a simple shared story of how the whole system works''} according to \cite[p.54]{xp:planning}. For example a metaphor for this system could be a pacer or a personal trainer. The problem analysis in \Cref{chap:analysis} describes the metaphor for this system.

\paragraph{Simple design} means that all the code in the program must serve a purpose. This is achieved by always focussing on solving the problem at hand, rather than adding code that might solve a future problem. To make sure the design stays simple constant refactoring and testing is done.

\paragraph{Testing} is implemented by writing unit tests before writing any production code. After the tests and production code are written, they are run frequently to ensure that everything is working as it is specified, especially after adding new features or refactoring a piece of code.

\paragraph{Refactoring} is done whenever a pair discoveres a piece of code, relevant to the issue they are working on, that could be implemented in a simpler way. Pair programing aids refactoring since two people programming together will be more likely to have the courage to refactor complicated pieces of code. The Testing practice also aids in this since tests can be run after refactoring which lessens the possibility of the code breaking.

This is a relatively short lived project, where some parts of the code may not need to change. Therefore, if a piece of code, that is outside the scope of the current issue a pair is working on, is discovered the pair should add a new issue which can later be estimated, prioritised, and included in a later iteration. This way, if the code is not refactored as part of another issue, it will eventually be anyway.This comes at the cost of spending time that could otherwise have been spent on developing other features, but ensures an overall higher quality code. 

\paragraph{Pair programming} provides an instant code review, and while it has some drawbacks, it encourages each team member to produce better quality code. With some trivial issues pair programming can seem like a waste of time, but it still strengthens some of the other practices, such as test writing and refactoring according to \citet[p. 102]{xp:explained}, making the extra time investment worth it.
\paragraph{Collective ownership} means that the whole team owns all the code. This means that if a bug appears, it is the team's problem, and if refactoring is needed, it should be done by the pair who discovers it rather than the pair who implemented it.

\paragraph{Continuous integration} is achieved by manually running all tests and running the application every time a branch is merged into the master branch. Each issue is solved on its own branch and merged into the master when the issue is solved. It is important that the master branch always works, i.e., tests must pass and the application should run without any significant issues.

\paragraph{40-hour week} is a practice that emphasises not working overtime. If there is not enough time to solve all issues this should be taken into account when planning for the next iteration instead of working late. People are less productive when they are tired, and while it will sometimes be necessary to work more than other, it is important to notice when productivity goes down and react to this accordingly. For us, the use of this practice is complicated by having to take the time spent on lectures into account, and instead working a specific amount of hours each week, we focus on regularly evaluating our productivity and adjusting according to that.
\Christoffer{$\uparrow$  This paragraph needs more rewriting???} %B-be gentle, senpai.
 
\paragraph{On-site costumer} is adapted a bit, as we serve as our own customer. This does not mean that each person can simple make up a requirement, but rather that the team as a whole should be asked whenever there is a question that would otherwise be directed at the customer. Additionally the team must fulfil the other tasks done by the customer, such as writing user stories and acceptance tests.

\paragraph{Coding standards} used are in an informal form. The group has worked together multiple times and as a result have adapted to writing code in a similar way. Differences between team members' code occur, but overall the code produced looks similar. The informal coding standards improve collective ownership since no one can necessarily say ``He wrote this code, I can tell. It's his problem!'' because the code looks alike. It also aids refactoring because the refactorer is used to the code conforming to a code standard and thus is easier to read and rewrite.\Christoffer{Yderligere tilf√∏jelser? Holder det vand?}
\Alexander{Should be elaborated upon.}